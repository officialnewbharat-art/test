<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interna - Internanda Interview Agent</title>
    <style>
        /* CSS Variables for Theming */
        :root {
            --color-primary: #007bff;
            --color-secondary: #6c757d;
            --color-success: #28a745;
            --color-danger: #dc3545;
            --color-warning: #ffc107;
            --color-light: #f8f9fa;
            --color-dark: #343a40;
            --color-background: #ffffff;
            --color-surface: #ffffff;
            --color-border: #dee2e6;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --spacing-unit: 8px;
            --header-height: 60px;
        }

        /* Base & Reset */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--color-light);
            color: var(--color-dark);
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }

        /* Accessibility & Focus */
        :focus {
            outline: 3px solid var(--color-primary);
            outline-offset: 2px;
        }

        a:focus, button:focus, input:focus, select:focus, textarea:focus {
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.5);
        }

        /* Layout Grid/Flexbox */
        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: calc(var(--spacing-unit) * 2);
        }

        .main-layout {
            display: grid;
            grid-template-areas: "sidebar" "content";
            gap: calc(var(--spacing-unit) * 3);
            flex-grow: 1;
        }

        @media (min-width: 900px) {
            .main-layout {
                grid-template-columns: 300px 1fr;
                grid-template-areas: "sidebar content";
                padding-top: var(--header-height); /* Space for sticky header */
            }
        }

        /* Header & Logo */
        header {
            background-color: var(--color-surface);
            border-bottom: 1px solid var(--color-border);
            padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        header img {
            height: calc(var(--header-height) - 20px);
            margin-right: var(--spacing-unit);
        }

        header h1 {
            font-size: 1.5rem;
            color: var(--color-primary);
            display: flex;
            align-items: center;
        }

        /* Sections and Cards */
        section {
            background-color: var(--color-surface);
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            margin-bottom: calc(var(--spacing-unit) * 3);
            grid-area: content;
        }

        .sidebar {
            grid-area: sidebar;
            background-color: var(--color-surface);
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        @media (min-width: 900px) {
            .sidebar {
                position: sticky;
                top: calc(var(--header-height) + var(--spacing-unit));
                height: calc(100vh - var(--header-height) - var(--spacing-unit) * 2);
                overflow-y: auto;
            }
        }


        h2 {
            font-size: 1.75rem;
            color: var(--color-dark);
            margin-bottom: calc(var(--spacing-unit) * 2);
            border-bottom: 2px solid var(--color-border);
            padding-bottom: var(--spacing-unit);
        }

        h3 {
            font-size: 1.25rem;
            color: var(--color-dark);
            margin-top: calc(var(--spacing-unit) * 2);
            margin-bottom: var(--spacing-unit);
        }

        /* Forms */
        .form-group {
            margin-bottom: calc(var(--spacing-unit) * 2);
        }

        label {
            display: block;
            margin-bottom: calc(var(--spacing-unit) / 2);
            font-weight: 600;
        }

        input[type="text"], input[type="email"], input[type="number"], select, textarea {
            width: 100%;
            padding: var(--spacing-unit);
            border: 1px solid var(--color-border);
            border-radius: 4px;
            font-size: 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        input[type="file"] {
            padding: 0;
            border: none;
        }

        textarea {
            resize: vertical;
        }

        input:focus, select:focus, textarea:focus {
            border-color: var(--color-primary);
        }

        /* Buttons */
        button {
            padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);
            border: none;
            border-radius: 4px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s, opacity 0.2s, transform 0.1s;
            font-weight: 600;
        }

        .btn-primary {
            background-color: var(--color-primary);
            color: var(--color-light);
        }

        .btn-secondary {
            background-color: var(--color-secondary);
            color: var(--color-light);
        }

        .btn-danger {
            background-color: var(--color-danger);
            color: var(--color-light);
        }

        button:hover:not(:disabled) {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .button-group {
            display: flex;
            gap: var(--spacing-unit);
            margin-top: calc(var(--spacing-unit) * 2);
        }

        /* Tabs */
        .tab-controls {
            display: flex;
            border-bottom: 2px solid var(--color-border);
            margin-bottom: calc(var(--spacing-unit) * 2);
        }

        .tab-button {
            background: none;
            border: none;
            padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);
            cursor: pointer;
            font-weight: 600;
            color: var(--color-secondary);
            border-bottom: 3px solid transparent;
            transition: color 0.2s, border-bottom-color 0.2s;
        }

        .tab-button.active {
            color: var(--color-primary);
            border-bottom-color: var(--color-primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Interview UI */
        #interview-screen {
            display: none;
        }

        #interview-screen.active {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: calc(var(--spacing-unit) * 3);
            min-height: 80vh;
        }
        
        @media (max-width: 900px) {
            #interview-screen.active {
                grid-template-columns: 1fr;
            }
        }

        .interview-main {
            display: flex;
            flex-direction: column;
        }

        .interview-controls {
            position: sticky;
            top: calc(var(--header-height) + var(--spacing-unit));
            background-color: var(--color-surface);
            padding: calc(var(--spacing-unit) * 2);
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: calc(var(--spacing-unit) * 3);
            z-index: 900;
        }
        
        @media (max-width: 900px) {
            .interview-controls {
                position: static;
                box-shadow: none;
                border-bottom: 1px solid var(--color-border);
                margin-bottom: var(--spacing-unit);
            }
        }

        .interview-transcript {
            flex-grow: 1;
        }

        .question-card {
            border: 1px solid var(--color-primary);
            padding: calc(var(--spacing-unit) * 2);
            border-radius: 8px;
            margin-bottom: calc(var(--spacing-unit) * 3);
            background-color: var(--color-light);
        }

        .transcript-item {
            border-bottom: 1px solid var(--color-border);
            padding-bottom: calc(var(--spacing-unit) * 2);
            margin-bottom: calc(var(--spacing-unit) * 2);
        }

        .transcript-item h4 {
            color: var(--color-primary);
            margin-bottom: var(--spacing-unit);
        }

        .transcript-meta {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: var(--color-secondary);
            margin-top: var(--spacing-unit);
        }

        .rating-input {
            display: flex;
            gap: var(--spacing-unit);
            align-items: center;
        }

        .rating-input label {
            font-weight: normal;
        }

        /* Utility */
        .hidden {
            display: none !important;
        }

        .alert {
            padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);
            margin-bottom: calc(var(--spacing-unit) * 2);
            border-radius: 4px;
            font-weight: 600;
        }

        .alert-danger {
            background-color: #f8d7da;
            color: var(--color-danger);
            border: 1px solid #f5c6cb;
        }

        .alert-success {
            background-color: #d4edda;
            color: var(--color-success);
            border: 1px solid #c3e6cb;
        }

        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-top: 4px solid var(--color-primary);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: var(--spacing-unit);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .flex-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-unit);
        }

        .chip {
            display: inline-block;
            padding: 4px 8px;
            background-color: var(--color-primary);
            color: var(--color-light);
            border-radius: 16px;
            font-size: 0.8rem;
            margin-right: 4px;
        }

        /* End Report Styles */
        #report-screen h3 {
            border-bottom: 1px dashed var(--color-border);
            padding-bottom: var(--spacing-unit);
            margin-top: calc(var(--spacing-unit) * 4);
        }
        
        .score-display {
            font-size: 3rem;
            font-weight: bold;
            color: var(--color-success);
            text-align: center;
        }

        .score-reason {
            text-align: center;
            font-style: italic;
            color: var(--color-secondary);
        }

    </style>
</head>
<body>
    <header role="banner">
        <h1>
            <img src="interna.png" alt="Interna Logo">
            Interna
        </h1>
        <div class="settings-control">
            <button id="show-settings-btn" class="btn-secondary" aria-controls="settings-panel" aria-expanded="false">‚öôÔ∏è Settings</button>
        </div>
    </header>

    <main class="container main-layout" role="main">
        <section id="settings-panel" class="sidebar hidden" role="dialog" aria-modal="true" aria-labelledby="settings-heading">
            <h2 id="settings-heading">‚öôÔ∏è Application Settings</h2>
            <div class="form-group">
                <label for="api-mode">API Mode (Default Recommended: Proxy)</label>
                <select id="api-mode" name="api-mode">
                    <option value="proxy">Use Local Proxy (/api/gemini)</option>
                    <option value="direct">Direct Client-Side API Key (Insecure!)</option>
                </select>
                <p style="font-size: 0.8rem; color: var(--color-danger); margin-top: 4px;">**WARNING:** Direct mode exposes your API key publicly. Only use for quick, local testing.</p>
            </div>
            <div class="form-group" id="api-key-group">
                <label for="gemini-api-key">Gemini API Key</label>
                <input type="text" id="gemini-api-key" placeholder="Paste your GEMINI_API_KEY here">
                <p style="font-size: 0.8rem; color: var(--color-secondary); margin-top: 4px;">In Proxy mode, this field is ignored. Set the key in your Node environment.</p>
            </div>
            <button id="save-settings-btn" class="btn-primary">Save Settings</button>
            <hr style="margin: 20px 0;">
            <h3>LLM Prompt Templates</h3>
            <p style="font-size: 0.9rem; color: var(--color-secondary);">Customize the prompts sent to the Gemini model.</p>
            <div class="form-group">
                <label for="prompt-question">Question Generation Prompt</label>
                <textarea id="prompt-question" rows="5" aria-label="Question Generation Prompt Template"></textarea>
            </div>
            <div class="form-group">
                <label for="prompt-summary">Answer Summary & Score Prompt</label>
                <textarea id="prompt-summary" rows="5" aria-label="Answer Summary and Score Prompt Template"></textarea>
            </div>
            <div class="form-group">
                <label for="prompt-followup">Follow-up Question Prompt</label>
                <textarea id="prompt-followup" rows="5" aria-label="Follow-up Question Prompt Template"></textarea>
            </div>
            <button id="save-prompts-btn" class="btn-secondary">Save Prompts</button>
        </section>

        <section id="config-screen" class="active">
            <h2 aria-live="polite">üìù Candidate Intake & Interview Setup</h2>
            <form id="intake-form">
                <h3>Candidate Details</h3>
                <div class="form-group">
                    <label for="candidate-name">Full Name *</label>
                    <input type="text" id="candidate-name" required aria-required="true" placeholder="Jane Doe">
                </div>
                <div class="form-group">
                    <label for="candidate-email">Email *</label>
                    <input type="email" id="candidate-email" required aria-required="true" placeholder="jane.doe@example.com">
                </div>
                <div class="form-group">
                    <label for="role-applied">Role Applied For *</label>
                    <input type="text" id="role-applied" required aria-required="true" placeholder="Senior Software Engineer">
                </div>
                <div class="form-group">
                    <label for="experience-years">Years of Experience *</label>
                    <input type="number" id="experience-years" min="0" required aria-required="true" value="3">
                </div>
                <div class="form-group">
                    <label for="resume-upload">Resume (Optional - Client-Side Read)</label>
                    <input type="file" id="resume-upload" accept=".txt,.pdf,.doc,.docx" aria-describedby="resume-help">
                    <p id="resume-help" style="font-size: 0.8rem; color: var(--color-secondary);">Plain text will be extracted for context.</p>
                    <textarea id="resume-text-preview" rows="5" placeholder="Resume text preview (if extracted)" readonly style="margin-top: 8px; display: none;"></textarea>
                </div>

                <hr style="margin: 20px 0;">

                <h3>Interview Configuration</h3>
                <div class="form-group">
                    <label for="interview-template">Template *</label>
                    <select id="interview-template" required aria-required="true">
                        <option value="Behavioral">Behavioral (STAR)</option>
                        <option value="Technical">Technical (Coding/System Design)</option>
                        <option value="Cultural-fit">Cultural Fit & Values</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="num-questions">Number of Questions (Adaptive Deck)</label>
                    <input type="number" id="num-questions" min="1" max="20" value="5">
                </div>
                <div class="form-group">
                    <label for="difficulty-level">Difficulty/Level</label>
                    <select id="difficulty-level">
                        <option value="Junior">Junior (0-2 YOE)</option>
                        <option value="Mid">Mid-Level (3-5 YOE)</option>
                        <option value="Senior">Senior (6+ YOE)</option>
                    </select>
                </div>

                <button type="submit" class="btn-primary" id="start-interview-btn">Start Interview</button>
            </form>
        </section>

        <section id="interview-screen" class="hidden" role="region" aria-live="polite">
            <div class="interview-main">
                <div class="interview-controls">
                    <div class="flex-row">
                        <h3>Current Question <span id="current-q-index">1</span> of <span id="total-q-count">5</span></h3>
                        <div class="timer-display">
                            üïí Total Time: <span id="total-timer">00:00</span> | Q Time: <span id="question-timer">00:00</span>
                        </div>
                    </div>
                    <div class="question-card">
                        <p id="current-question-text" role="status">The first question will load here...</p>
                        <div id="q-loading" class="hidden">Generating question... <span class="loading-spinner"></span></div>
                    </div>
                    
                    <div class="form-group">
                        <label for="candidate-answer">Candidate's Raw Answer (Type or Transcribe)</label>
                        <textarea id="candidate-answer" rows="5" placeholder="Type the candidate's answer here. Max 1200 characters." maxlength="1200" aria-label="Candidate Answer"></textarea>
                        <div style="text-align: right; font-size: 0.8rem; color: var(--color-secondary);"><span id="char-count">0</span>/1200</div>
                    </div>
                    
                    <div class="form-group">
                        <label for="interviewer-notes">Interviewer Notes</label>
                        <textarea id="interviewer-notes" rows="3" placeholder="Private notes on delivery, demeanor, and context."></textarea>
                    </div>

                    <div class="form-group flex-row">
                        <div class="rating-input">
                            <label for="answer-quality">Answer Quality:</label>
                            <input type="range" id="answer-quality" min="1" max="5" step="1" value="3" aria-valuemin="1" aria-valuemax="5" aria-valuenow="3">
                            <span id="quality-display">3/5</span>
                        </div>
                        <div class="tag-input">
                            <label for="skill-tags">Skill Tags (comma separated):</label>
                            <input type="text" id="skill-tags" placeholder="e.g., JS, leadership, architecture">
                        </div>
                    </div>

                    <div class="button-group">
                        <button id="suggest-followup-btn" class="btn-secondary" aria-controls="followup-suggestions">Suggest Follow-up</button>
                        <button id="submit-answer-btn" class="btn-primary">Submit Answer & Next Question</button>
                        <button id="end-interview-btn" class="btn-danger">End Interview</button>
                    </div>

                    <div id="followup-suggestions" class="alert hidden" role="status" style="margin-top: 10px;">
                        <strong>Suggested Follow-ups:</strong>
                        <ul id="followup-list" style="margin-left: 20px; margin-top: 5px;"></ul>
                        <div id="followup-loading" class="hidden">Generating suggestions... <span class="loading-spinner"></span></div>
                    </div>
                </div>

                <div class="interview-transcript">
                    <h2>Live Transcript & Summary</h2>
                    <div id="transcript-list" aria-live="polite">
                        </div>
                </div>
            </div>

            <div class="interview-debug">
                <h2>API Status</h2>
                <div id="status-alert" class="alert hidden" role="alert" aria-atomic="true"></div>
                <button id="run-self-test-btn" class="btn-secondary">Run Self-Test</button>
                <div id="self-test-results" style="margin-top: 10px; font-size: 0.9rem;"></div>
            </div>
        </section>

        <section id="report-screen" class="hidden">
            <h2 aria-live="polite">üìÑ Interview Report for <span id="report-candidate-name"></span></h2>
            
            <div class="flex-row" style="margin-bottom: 20px;">
                <div style="flex: 1;">
                    <h3>Overall Score</h3>
                    <div class="score-display" id="final-avg-score">N/A</div>
                    <div class="score-reason" id="final-score-reason">Based on average of all question scores (1-5).</div>
                </div>
                <div style="flex: 1;">
                    <h3>Metadata</h3>
                    <p><strong>Role:</strong> <span id="report-role"></span></p>
                    <p><strong>Experience:</strong> <span id="report-exp"></span> years</p>
                    <p><strong>Template:</strong> <span id="report-template"></span></p>
                    <p><strong>Total Duration:</strong> <span id="report-duration"></span></p>
                </div>
            </div>

            <h3>Key Findings (Gemini Synthesis)</h3>
            <div id="report-synthesis">
                <p>Generating summary... <span class="loading-spinner"></span></p>
            </div>

            <h3 style="margin-top: 40px;">Detailed Q&A Transcript</h3>
            <div id="report-transcript-list">
                </div>

            <div class="button-group" style="margin-top: 30px;">
                <button id="download-json-btn" class="btn-primary">Download JSON</button>
                <button id="download-csv-btn" class="btn-secondary">Download CSV</button>
                <button id="print-pdf-btn" class="btn-secondary">Print Report (PDF)</button>
                <button id="reset-app-btn" class="btn-danger">Start New Interview</button>
            </div>
        </section>
    </main>

    <script>
        // Filename: index.html (JavaScript)

        const CONFIG = {
            appName: "Interna",
            company: "Internanda",
            maxAnswerChars: 1200,
            proxyEndpoint: '/api/gemini',
            // NOTE: This key is INSECURE for public-facing apps. Only use for quick, local demos.
            // For production, use the 'proxy' mode and set the key in the server's environment.
            INLINE_API_KEY: "" 
        };

        const STATE = {
            apiMode: 'proxy',
            apiKey: CONFIG.INLINE_API_KEY,
            proxyEnabled: true,
            isInterviewActive: false,
            currentQuestionIndex: 0,
            totalQuestions: 5,
            questions: [], // { text: "Q", time: 0, difficulty: "Mid" }
            answers: [], // { question: "Q", rawAnswer: "A", interviewerNotes: "N", rating: 4, tags: "T", summary: "S", geminiScore: 4, geminiReason: "R", qTime: "00:00" }
            candidate: {}, // { name, email, role, exp, resumeText }
            interviewConfig: {}, // { template, difficulty }
            timers: { total: 0, question: 0, totalInterval: null, questionInterval: null },
            debounceTimeout: null,
            rateLimitTimer: 0
        };

        const PROMPTS = {
            QUESTION_GENERATION: (role, exp, template, difficulty, resume) => `You are an expert interviewer for ${CONFIG.company}. Generate a single, concise interview question for a candidate applying for the role of "${role}" with ${exp} years of experience. The interview template is "${template}" and the difficulty level is "${difficulty}". The candidate's resume highlights are: "${resume.substring(0, 500)}".
            The question must be relevant to the context. Output ONLY the question text. Do not provide any other commentary, preamble, or formatting.`,

            ANSWER_SUMMARY_SCORING: (question, rawAnswer) => `Analyze the following candidate's raw answer to the question: "${question}".
            1. **Summary:** Produce a one-paragraph summary (1-3 sentences) of the answer.
            2. **Score (1-5):** Assign a numeric score from 1 (poor) to 5 (excellent).
            3. **Justification:** Provide a single, concise sentence explaining the score.
            4. **Strengths:** List 3 specific strengths of the answer.
            5. **Weaknesses:** List 3 specific weaknesses or areas for improvement.
            Output your response in a parseable JSON format: {"summary": "...", "score": 4, "reason": "...", "strengths": ["...", "...", "..."], "weaknesses": ["...", "...", "..."]}. Do not include any other text.`,

            FOLLOW_UP_SUGGESTION: (question, rawAnswer) => `Based on the candidate's raw answer: "${rawAnswer}", to the question: "${question}", suggest 1-2 concise, probing follow-up questions to delve deeper or clarify points.
            Output ONLY a JSON array of strings: ["Follow-up Q 1...", "Follow-up Q 2..."]. Do not include any other text.`,

            REPORT_SYNTHESIS: (report) => `Review the following consolidated interview report data: ${JSON.stringify(report, null, 2)}.
            Provide a professional, actionable end-of-interview report summary including:
            1. An overall assessment paragraph (1-3 sentences).
            2. A bulleted list of 3-5 key strengths across the interview.
            3. A bulleted list of 3-5 key weaknesses/gaps identified.
            4. A hiring recommendation (Strong Yes/Yes/Leaning No/No).
            Output the response as formatted markdown text.`
        };

        // --- DOM Elements ---
        const D = {
            // Screens
            configScreen: document.getElementById('config-screen'),
            interviewScreen: document.getElementById('interview-screen'),
            reportScreen: document.getElementById('report-screen'),
            settingsPanel: document.getElementById('settings-panel'),
            // Forms/Inputs
            intakeForm: document.getElementById('intake-form'),
            candidateName: document.getElementById('candidate-name'),
            candidateEmail: document.getElementById('candidate-email'),
            roleApplied: document.getElementById('role-applied'),
            experienceYears: document.getElementById('experience-years'),
            resumeUpload: document.getElementById('resume-upload'),
            resumeTextPreview: document.getElementById('resume-text-preview'),
            interviewTemplate: document.getElementById('interview-template'),
            numQuestions: document.getElementById('num-questions'),
            difficultyLevel: document.getElementById('difficulty-level'),
            // Settings
            showSettingsBtn: document.getElementById('show-settings-btn'),
            saveSettingsBtn: document.getElementById('save-settings-btn'),
            apiMode: document.getElementById('api-mode'),
            apiKeyInput: document.getElementById('gemini-api-key'),
            apiKeyGroup: document.getElementById('api-key-group'),
            // Prompts
            savePromptsBtn: document.getElementById('save-prompts-btn'),
            promptQuestion: document.getElementById('prompt-question'),
            promptSummary: document.getElementById('prompt-summary'),
            promptFollowup: document.getElementById('prompt-followup'),
            // Interview UI
            currentQuestionText: document.getElementById('current-question-text'),
            qLoading: document.getElementById('q-loading'),
            currentQIndex: document.getElementById('current-q-index'),
            totalQCount: document.getElementById('total-q-count'),
            totalTimer: document.getElementById('total-timer'),
            questionTimer: document.getElementById('question-timer'),
            candidateAnswer: document.getElementById('candidate-answer'),
            charCount: document.getElementById('char-count'),
            interviewerNotes: document.getElementById('interviewer-notes'),
            answerQuality: document.getElementById('answer-quality'),
            qualityDisplay: document.getElementById('quality-display'),
            skillTags: document.getElementById('skill-tags'),
            suggestFollowupBtn: document.getElementById('suggest-followup-btn'),
            followupSuggestions: document.getElementById('followup-suggestions'),
            followupList: document.getElementById('followup-list'),
            followupLoading: document.getElementById('followup-loading'),
            submitAnswerBtn: document.getElementById('submit-answer-btn'),
            endInterviewBtn: document.getElementById('end-interview-btn'),
            transcriptList: document.getElementById('transcript-list'),
            // Debug/Status
            statusAlert: document.getElementById('status-alert'),
            runSelfTestBtn: document.getElementById('run-self-test-btn'),
            selfTestResults: document.getElementById('self-test-results'),
            // Report UI
            reportCandidateName: document.getElementById('report-candidate-name'),
            reportRole: document.getElementById('report-role'),
            reportExp: document.getElementById('report-exp'),
            reportTemplate: document.getElementById('report-template'),
            reportDuration: document.getElementById('report-duration'),
            finalAvgScore: document.getElementById('final-avg-score'),
            finalScoreReason: document.getElementById('final-score-reason'),
            reportSynthesis: document.getElementById('report-synthesis'),
            reportTranscriptList: document.getElementById('report-transcript-list'),
            downloadJsonBtn: document.getElementById('download-json-btn'),
            downloadCsvBtn: document:getElementById('download-csv-btn'),
            printPdfBtn: document.getElementById('print-pdf-btn'),
            resetAppBtn: document.getElementById('reset-app-btn'),
        };

        // --- Core API Abstraction ---
        /**
         * Converts state.timers.total (seconds) to MM:SS format.
         * @param {number} totalSeconds 
         * @returns {string}
         */
        const formatTime = (totalSeconds) => {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        };

        /**
         * Displays a non-intrusive status alert.
         * @param {string} message 
         * @param {'danger' | 'success'} type 
         * @param {number} durationMs 
         */
        const showAlert = (message, type = 'danger', durationMs = 5000) => {
            D.statusAlert.textContent = message;
            D.statusAlert.className = `alert alert-${type}`;
            D.statusAlert.classList.remove('hidden');
            clearTimeout(STATE.alertTimeout);
            STATE.alertTimeout = setTimeout(() => {
                D.statusAlert.classList.add('hidden');
            }, durationMs);
        };

        /**
         * LLM API Helper Function. Calls Gemini API either via proxy or direct.
         * @param {string} prompt The text prompt to send to the model.
         * @returns {Promise<string>} The raw text response from the model.
         */
        const callGeminiAPI = async (prompt, isJson = false) => {
            if (Date.now() < STATE.rateLimitTimer) {
                throw new Error("Rate limit exceeded. Wait a few seconds before trying again.");
            }
            STATE.rateLimitTimer = Date.now() + 2000; // 2 second delay between calls

            const baseBody = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
                config: {
                    maxOutputTokens: 2048,
                    temperature: isJson ? 0.2 : 0.7, // Lower temp for JSON output
                },
            };
            
            const modelName = "gemini-2.5-flash"; // Use a fast model for interview flow

            try {
                if (STATE.proxyEnabled) {
                    // 1. Proxy Mode
                    const response = await fetch(CONFIG.proxyEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt: prompt, model: modelName, isJson: isJson }),
                    });

                    if (!response.ok) {
                        const error = await response.json().catch(() => ({ message: response.statusText }));
                        throw new Error(`Proxy/API Error: ${response.status} - ${error.message || response.statusText}`);
                    }
                    
                    const result = await response.json();
                    return result.text; // Expecting { text: "..." } from proxy
                } else {
                    // 2. Direct Client-Side API Call (Insecure, for demo only)
                    if (!STATE.apiKey) {
                        throw new Error("API Key not set in direct mode. Please update settings.");
                    }
                    const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${STATE.apiKey}`;

                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(baseBody),
                    });

                    if (!response.ok) {
                         const error = await response.json().catch(() => ({ message: response.statusText }));
                         throw new Error(`Direct API Error: ${response.status} - ${error.error?.message || error.message}`);
                    }

                    const result = await response.json();
                    // Extract text from the complex response structure
                    return result.candidates[0].content.parts[0].text;
                }
            } catch (error) {
                console.error("Gemini API Call Failed:", error);
                showAlert(`API Error: ${error.message}. Check console for details.`, 'danger');
                throw error; // Re-throw to be caught by specific flow handlers
            }
        };

        // --- Question Generator & Fallback ---

        /**
         * Generates the next question or uses a fallback.
         */
        const generateNextQuestion = async () => {
            D.qLoading.classList.remove('hidden');
            D.currentQuestionText.textContent = "Generating question...";
            D.submitAnswerBtn.disabled = true;

            const { role, exp, resumeText } = STATE.candidate;
            const { template, difficulty } = STATE.interviewConfig;
            const questionIndex = STATE.currentQuestionIndex + 1;

            const prompt = PROMPTS.QUESTION_GENERATION(
                role, exp, template, difficulty, resumeText || "No resume provided."
            );

            try {
                const text = await callGeminiAPI(prompt, false);
                const question = text.trim();
                
                // Save generated question to state
                STATE.questions[questionIndex] = {
                    text: question,
                    difficulty: difficulty,
                    time: 0,
                };
                D.currentQuestionText.textContent = question;
            } catch (error) {
                // Fallback deterministic question generator
                console.warn("API question generation failed. Using local fallback.");
                const fallbackQ = `[FALLBACK Q ${questionIndex}/${STATE.totalQuestions}] Describe a time you faced a difficult challenge (${template} focus) in your ${role} role, and how you overcame it.`;
                 STATE.questions[questionIndex] = {
                    text: fallbackQ,
                    difficulty: difficulty,
                    time: 0,
                };
                D.currentQuestionText.textContent = fallbackQ;
                showAlert('API failed to generate question. Using a deterministic fallback.', 'warning', 10000);
            } finally {
                D.qLoading.classList.add('hidden');
                D.submitAnswerBtn.disabled = false;
                startQuestionTimer();
            }
        };

        // --- Resume Handling ---
        const handleResumeUpload = () => {
            const file = D.resumeUpload.files[0];
            if (!file) {
                STATE.candidate.resumeText = "";
                D.resumeTextPreview.style.display = 'none';
                D.resumeTextPreview.value = '';
                return;
            }

            const fileName = file.name;
            const reader = new FileReader();

            reader.onload = (e) => {
                const text = e.target.result;
                // Simple text sanitization and truncation
                STATE.candidate.resumeText = text.replace(/[\n\r\t]+/g, ' ').trim().substring(0, 3000);
                D.resumeTextPreview.value = STATE.candidate.resumeText ? 
                    `[TEXT EXTRACTED] ${STATE.candidate.resumeText.substring(0, 300)}...` : 
                    `[COULD NOT EXTRACT TEXT] Using filename and size: ${fileName}, ${file.size} bytes.`;
                D.resumeTextPreview.style.display = 'block';
            };

            reader.onerror = () => {
                console.error("Error reading file.");
                STATE.candidate.resumeText = `File: ${fileName}, Type: ${file.type}, Size: ${file.size} bytes.`;
                D.resumeTextPreview.value = `[ERROR READING FILE] Using metadata only.`;
                D.resumeTextPreview.style.display = 'block';
            };

            // Read as text, or if PDF, we just use metadata/filename as fallback for client-side
            if (file.type.match('text.*') || file.type.match('.doc.*')) {
                reader.readAsText(file);
            } else if (file.type.match('application/pdf')) {
                // For a real app, use a server-side library like Tesseract/pdf-parse
                // For client-side demo, we use filename/metadata as context
                STATE.candidate.resumeText = `PDF File uploaded: ${fileName}. Professional context for role ${D.roleApplied.value} and ${D.experienceYears.value} years experience.`;
                D.resumeTextPreview.value = `[PDF UPLOADED] Client-side extraction not supported. Using metadata/filename as context.`;
                D.resumeTextPreview.style.display = 'block';
            } else {
                 reader.readAsText(file); // Try to read as text anyway
            }
        };

        // --- Timer Controls ---
        const startTimers = () => {
            if (STATE.timers.totalInterval) return;
            
            STATE.timers.totalInterval = setInterval(() => {
                STATE.timers.total++;
                D.totalTimer.textContent = formatTime(STATE.timers.total);
            }, 1000);
        };

        const stopTimers = () => {
            clearInterval(STATE.timers.totalInterval);
            clearInterval(STATE.timers.questionInterval);
            STATE.timers.totalInterval = null;
            STATE.timers.questionInterval = null;
        };
        
        const startQuestionTimer = () => {
            clearInterval(STATE.timers.questionInterval);
            STATE.timers.question = 0;
            D.questionTimer.textContent = formatTime(STATE.timers.question);
            
            STATE.timers.questionInterval = setInterval(() => {
                STATE.timers.question++;
                D.questionTimer.textContent = formatTime(STATE.timers.question);
            }, 1000);
        };

        const stopQuestionTimer = () => {
            clearInterval(STATE.timers.questionInterval);
            STATE.questions[STATE.currentQuestionIndex].time = STATE.timers.question;
        };


        // --- Interview Flow Logic ---

        const startInterview = (event) => {
            event.preventDefault();
            
            // 1. Gather & Validate Intake Data
            if (!D.intakeForm.checkValidity()) {
                D.intakeForm.reportValidity();
                showAlert('Please fill in all required fields.', 'danger');
                return;
            }

            STATE.candidate = {
                name: D.candidateName.value,
                email: D.candidateEmail.value,
                role: D.roleApplied.value,
                exp: parseInt(D.experienceYears.value),
                resumeText: STATE.candidate.resumeText || "No resume provided."
            };

            STATE.interviewConfig = {
                template: D.interviewTemplate.value,
                numQuestions: parseInt(D.numQuestions.value),
                difficulty: D.difficultyLevel.value
            };

            STATE.totalQuestions = STATE.interviewConfig.numQuestions;
            STATE.currentQuestionIndex = 0;
            STATE.answers = [];
            STATE.questions = [];
            STATE.timers.total = 0;
            STATE.timers.question = 0;
            D.transcriptList.innerHTML = '';
            D.totalQCount.textContent = STATE.totalQuestions;

            // 2. Switch Screens
            D.configScreen.classList.remove('active');
            D.interviewScreen.classList.add('active');
            D.reportScreen.classList.add('hidden');
            STATE.isInterviewActive = true;

            // 3. Start Timers
            startTimers();
            
            // 4. Load First Question
            nextQuestion();
        };

        const nextQuestion = () => {
            if (!STATE.isInterviewActive) return;

            // Stop timer for previous question
            if (STATE.currentQuestionIndex > 0) {
                stopQuestionTimer();
            }

            // Check if interview is finished
            if (STATE.currentQuestionIndex >= STATE.totalQuestions) {
                endInterview();
                return;
            }

            // Increment and update UI
            STATE.currentQuestionIndex++;
            D.currentQIndex.textContent = STATE.currentQuestionIndex;
            
            // Reset input fields
            D.candidateAnswer.value = '';
            D.charCount.textContent = '0';
            D.interviewerNotes.value = '';
            D.answerQuality.value = 3;
            D.qualityDisplay.textContent = '3/5';
            D.skillTags.value = '';
            D.followupSuggestions.classList.add('hidden');
            D.followupList.innerHTML = '';


            // Generate the next question
            generateNextQuestion();
        };

        const submitAnswer = async () => {
            const rawAnswer = D.candidateAnswer.value.trim();
            if (rawAnswer.length < 5) {
                showAlert('Please record a more substantial answer (min 5 characters).', 'warning');
                return;
            }

            // 1. Save local interview data
            stopQuestionTimer();
            D.submitAnswerBtn.disabled = true;
            D.submitAnswerBtn.textContent = 'Submitting...';
            D.suggestFollowupBtn.disabled = true;

            const currentQ = STATE.questions[STATE.currentQuestionIndex];
            const newAnswer = {
                question: currentQ.text,
                rawAnswer: rawAnswer,
                interviewerRating: parseInt(D.answerQuality.value),
                interviewerNotes: D.interviewerNotes.value.trim(),
                tags: D.skillTags.value.split(',').map(tag => tag.trim()).filter(tag => tag),
                qTime: formatTime(currentQ.time),
                geminiScore: null,
                geminiReason: 'Analyzing...',
                summary: 'Analyzing...',
                strengths: [],
                weaknesses: []
            };
            STATE.answers.push(newAnswer);


            // 2. Update Transcript with placeholder
            const transcriptItem = createTranscriptItem(STATE.currentQuestionIndex, newAnswer, true);
            D.transcriptList.prepend(transcriptItem);


            // 3. Call LLM for summary & scoring
            const summaryPrompt = PROMPTS.ANSWER_SUMMARY_SCORING(newAnswer.question, newAnswer.rawAnswer);
            let geminiResult;
            try {
                const rawJson = await callGeminiAPI(summaryPrompt, true);
                // The model might add ```json wrappers, so we clean it up
                const cleanJson = rawJson.replace(/```json\n|```/g, '').trim();
                geminiResult = JSON.parse(cleanJson);

                // Update state with Gemini results
                newAnswer.summary = geminiResult.summary || 'Summary not provided.';
                newAnswer.geminiScore = geminiResult.score || newAnswer.interviewerRating;
                newAnswer.geminiReason = geminiResult.reason || 'Reason not provided.';
                newAnswer.strengths = geminiResult.strengths || [];
                newAnswer.weaknesses = geminiResult.weaknesses || [];
                
                // Update the transcript item
                updateTranscriptItem(transcriptItem, newAnswer);
                showAlert(`Q${STATE.currentQuestionIndex} analyzed successfully!`, 'success', 3000);

            } catch (error) {
                console.error("Gemini Summary/Scoring Failed:", error);
                newAnswer.summary = "ERROR: Could not generate summary. See console for details.";
                newAnswer.geminiScore = newAnswer.interviewerRating; // Fallback to interviewer's rating
                newAnswer.geminiReason = "API analysis failed. Using interviewer's score.";
                updateTranscriptItem(transcriptItem, newAnswer);
                showAlert(`API analysis failed for Q${STATE.currentQuestionIndex}.`, 'danger');
            } finally {
                D.submitAnswerBtn.disabled = false;
                D.submitAnswerBtn.textContent = 'Submit Answer & Next Question';
                D.suggestFollowupBtn.disabled = false;
                
                // 4. Move to next question
                nextQuestion();
            }
        };

        const suggestFollowUp = async () => {
            const rawAnswer = D.candidateAnswer.value.trim();
            if (rawAnswer.length < 5) {
                showAlert('Please provide an answer first before suggesting follow-ups.', 'warning');
                return;
            }

            D.suggestFollowupBtn.disabled = true;
            D.followupSuggestions.classList.remove('hidden');
            D.followupList.innerHTML = '';
            D.followupLoading.classList.remove('hidden');

            const currentQ = STATE.questions[STATE.currentQuestionIndex];
            const prompt = PROMPTS.FOLLOW_UP_SUGGESTION(currentQ.text, rawAnswer);
            
            try {
                const rawJson = await callGeminiAPI(prompt, true);
                const cleanJson = rawJson.replace(/```json\n|```/g, '').trim();
                const followups = JSON.parse(cleanJson);
                
                D.followupList.innerHTML = '';
                if (Array.isArray(followups) && followups.length > 0) {
                    followups.forEach(q => {
                        const li = document.createElement('li');
                        li.textContent = q;
                        D.followupList.appendChild(li);
                    });
                } else {
                    D.followupList.innerHTML = '<li>No specific follow-up questions were suggested.</li>';
                }

            } catch (error) {
                console.error("Gemini Follow-up Failed:", error);
                D.followupList.innerHTML = '<li>ERROR: Failed to generate follow-ups.</li>';
                showAlert('API failed to generate follow-ups.', 'danger');
            } finally {
                D.followupLoading.classList.add('hidden');
                D.suggestFollowupBtn.disabled = false;
            }
        };

        // --- UI Rendering ---

        /**
         * Creates an HTML element for a transcript item.
         * @param {number} qIndex 
         * @param {object} answerData 
         * @param {boolean} isLoading 
         * @returns {HTMLElement}
         */
        const createTranscriptItem = (qIndex, answerData, isLoading = false) => {
            const div = document.createElement('div');
            div.className = 'transcript-item';
            div.id = `transcript-item-${qIndex}`;

            let html = `
                <h4>Q${qIndex}: ${answerData.question}</h4>
                <p><strong>Raw Answer:</strong> ${answerData.rawAnswer}</p>
                
                <div class="transcript-meta">
                    <span>Interviewer Rating: <strong>${answerData.interviewerRating}/5</strong></span>
                    <span>Q Time: <strong>${answerData.qTime}</strong></span>
                </div>
                
                <h5 style="margin-top: 10px;">Gemini Summary & Analysis:</h5>
                <div id="summary-${qIndex}" style="padding-left: 10px; border-left: 2px solid var(--color-primary);">
                    <p><strong>Summary:</strong> <span class="summary-text">${answerData.summary}</span></p>
                    <p><strong>Gemini Score:</strong> <span class="score-text">${answerData.geminiScore || (isLoading ? '...' : 'N/A')}</span>/5 
                        (<span class="reason-text">${answerData.geminiReason}</span>)
                        ${isLoading ? '<span class="loading-spinner"></span>' : ''}
                    </p>
                    <p style="font-size: 0.9rem;">
                        <strong>Strengths:</strong> <span class="strengths-text">${answerData.strengths.join(', ') || 'N/A'}</span>
                    </p>
                    <p style="font-size: 0.9rem;">
                        <strong>Weaknesses:</strong> <span class="weaknesses-text">${answerData.weaknesses.join(', ') || 'N/A'}</span>
                    </p>
                </div>
            `;
            div.innerHTML = html;
            return div;
        };
        
        /**
         * Updates an existing transcript item with final API data.
         * @param {HTMLElement} itemElement 
         * @param {object} answerData 
         */
        const updateTranscriptItem = (itemElement, answerData) => {
            const qIndex = STATE.answers.findIndex(a => a === answerData) + 1;
            itemElement.querySelector(`.summary-text`).textContent = answerData.summary;
            itemElement.querySelector(`.score-text`).textContent = answerData.geminiScore;
            itemElement.querySelector(`.reason-text`).textContent = answerData.geminiReason;
            itemElement.querySelector(`.strengths-text`).textContent = answerData.strengths.join(', ');
            itemElement.querySelector(`.weaknesses-text`).textContent = answerData.weaknesses.join(', ');
            const spinner = itemElement.querySelector(`.loading-spinner`);
            if (spinner) spinner.remove();
        };
        
        const endInterview = async () => {
            stopTimers();
            STATE.isInterviewActive = false;
            
            // Switch screen
            D.interviewScreen.classList.remove('active');
            D.reportScreen.classList.remove('hidden');

            // Populate metadata
            D.reportCandidateName.textContent = STATE.candidate.name;
            D.reportRole.textContent = STATE.candidate.role;
            D.reportExp.textContent = STATE.candidate.exp;
            D.reportTemplate.textContent = STATE.interviewConfig.template;
            D.reportDuration.textContent = formatTime(STATE.timers.total);
            D.reportSynthesis.innerHTML = '<p>Generating summary... <span class="loading-spinner"></span></p>';
            
            // Calculate final score
            const validScores = STATE.answers.map(a => a.geminiScore).filter(s => typeof s === 'number');
            const avgScore = validScores.length > 0 
                ? (validScores.reduce((sum, s) => sum + s, 0) / validScores.length).toFixed(2)
                : 'N/A';
            D.finalAvgScore.textContent = avgScore;
            D.finalScoreReason.textContent = `Average score from ${validScores.length} questions.`;

            // Prepare report data structure
            const reportData = {
                metadata: {
                    appName: CONFIG.appName,
                    company: CONFIG.company,
                    timestamp: new Date().toISOString(),
                    totalDuration: D.reportDuration.textContent,
                    averageScore: avgScore,
                    ...STATE.candidate,
                    ...STATE.interviewConfig
                },
                qa_transcript: STATE.answers
            };

            // Generate synthesis report
            try {
                const synthesisPrompt = PROMPTS.REPORT_SYNTHESIS(reportData);
                const markdownReport = await callGeminiAPI(synthesisPrompt, false);
                D.reportSynthesis.innerHTML = parseMarkdownToHtml(markdownReport);
            } catch (error) {
                console.error("Report Synthesis Failed:", error);
                D.reportSynthesis.innerHTML = '<p style="color: var(--color-danger);">ERROR: Failed to generate a summary report from the API.</p>';
            }

            // Populate detailed transcript
            D.reportTranscriptList.innerHTML = '';
            STATE.answers.forEach((answer, index) => {
                const item = document.createElement('div');
                item.className = 'transcript-item';
                item.style.border = '1px solid var(--color-border)';
                item.style.padding = '15px';
                item.style.marginBottom = '15px';
                
                const avgRating = answer.geminiScore ? `${answer.geminiScore}/5 (Gemini)` : `${answer.interviewerRating}/5 (Interviewer)`;
                
                item.innerHTML = `
                    <h4>Question ${index + 1}: ${answer.question}</h4>
                    <p style="font-style: italic; color: var(--color-secondary);">Time Taken: ${answer.qTime}</p>
                    
                    <h5 style="margin-top: 10px;">Candidate Answer:</h5>
                    <blockquote style="background-color: var(--color-light); padding: 8px; border-left: 4px solid var(--color-secondary); margin: 5px 0;">${answer.rawAnswer}</blockquote>
                    
                    <h5 style="margin-top: 10px;">Summary & Score:</h5>
                    <p><strong>Score:</strong> <span style="font-weight: bold; color: ${answer.geminiScore >= 4 ? 'var(--color-success)' : answer.geminiScore <= 2 ? 'var(--color-danger)' : 'var(--color-warning)'};">${avgRating}</span></p>
                    <p style="font-size: 0.9rem; color: var(--color-secondary);"><strong>Reason:</strong> ${answer.geminiReason}</p>
                    <p><strong>Summary:</strong> ${answer.summary}</p>

                    <h5 style="margin-top: 10px;">Analysis:</h5>
                    <p style="font-size: 0.9rem;"><strong>Interviewer Notes:</strong> ${answer.interviewerNotes || 'N/A'}</p>
                    <p style="font-size: 0.9rem;"><strong>Skills Tagged:</strong> ${answer.tags.map(tag => `<span class="chip" style="background-color: var(--color-secondary);">${tag}</span>`).join(' ') || 'N/A'}</p>
                    <p style="font-size: 0.9rem;"><strong>Strengths:</strong> ${answer.strengths.join('; ') || 'N/A'}</p>
                    <p style="font-size: 0.9rem;"><strong>Weaknesses:</strong> ${answer.weaknesses.join('; ') || 'N/A'}</p>
                `;
                D.reportTranscriptList.appendChild(item);
            });

            // Set up download handlers
            D.downloadJsonBtn.onclick = () => downloadFile(JSON.stringify(reportData, null, 2), `${STATE.candidate.name.replace(/\s/g, '_')}_Interna_Report.json`, 'application/json');
            D.downloadCsvBtn.onclick = () => downloadFile(convertToCsv(reportData), `${STATE.candidate.name.replace(/\s/g, '_')}_Interna_Report.csv`, 'text/csv');
            D.printPdfBtn.onclick = () => window.print(); // Use browser print function
        };

        // --- Data Handling & Utilities ---

        /**
         * Simple Markdown to HTML converter (for synthesis report).
         * @param {string} markdown 
         * @returns {string}
         */
        const parseMarkdownToHtml = (markdown) => {
            let html = markdown
                .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                .replace(/^\* (.*$)/gim, '<li>$1</li>')
                .replace(/^- (.*$)/gim, '<li>$1</li>');

            // Wrap lists
            html = html.replace(/(<li>.*<\/li>)/gms, '<ul>$1</ul>');
            
            // Bold
            html = html.replace(/\*\*(.*?)\*\*/gim, '<strong>$1</strong>');
            
            // Paragraphs (if not already handled by a block element)
            html = html.split('\n\n').map(p => {
                if (!p.match(/<h|<ul|<ol|<li|<p/)) {
                    return `<p>${p.trim()}</p>`;
                }
                return p;
            }).join('');

            return html;
        };

        /**
         * Converts report data to CSV format.
         * @param {object} data 
         * @returns {string}
         */
        const convertToCsv = (data) => {
            const qa = data.qa_transcript;
            if (qa.length === 0) return "No data to report.";
            
            const headers = [
                "Question Index", "Question", "Raw Answer", "Interviewer Rating", "Gemini Score", 
                "Gemini Reason", "Summary", "Strengths", "Weaknesses", "Interviewer Notes", "Skill Tags", "Time Taken"
            ];
            
            const rows = qa.map((a, i) => [
                i + 1,
                `"${a.question.replace(/"/g, '""')}"`,
                `"${a.rawAnswer.replace(/"/g, '""')}"`,
                a.interviewerRating,
                a.geminiScore,
                `"${a.geminiReason.replace(/"/g, '""')}"`,
                `"${a.summary.replace(/"/g, '""')}"`,
                `"${a.strengths.join('; ').replace(/"/g, '""')}"`,
                `"${a.weaknesses.join('; ').replace(/"/g, '""')}"`,
                `"${a.interviewerNotes.replace(/"/g, '""')}"`,
                `"${a.tags.join('; ').replace(/"/g, '""')}"`,
                a.qTime
            ]);

            let csvString = headers.join(',') + "\n";
            rows.forEach(row => {
                csvString += row.join(',') + "\n";
            });

            return csvString;
        };

        /**
         * Initiates a file download in the browser.
         * @param {string} content 
         * @param {string} filename 
         * @param {string} contentType 
         */
        const downloadFile = (content, filename, contentType) => {
            const blob = new Blob([content], { type: contentType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        // --- Settings and Initialization ---

        const loadSettings = () => {
            const storedSettings = localStorage.getItem('interna_settings');
            if (storedSettings) {
                const settings = JSON.parse(storedSettings);
                STATE.apiMode = settings.apiMode;
                STATE.apiKey = settings.apiKey;
                STATE.proxyEnabled = settings.apiMode === 'proxy';
                D.apiMode.value = settings.apiMode;
                D.apiKeyInput.value = settings.apiKey;
            }
            // Update UI based on initial load
            updateSettingsUI();

            // Load Prompts
            D.promptQuestion.value = localStorage.getItem('prompt_question') || PROMPTS.QUESTION_GENERATION(
                'Software Engineer', 3, 'Technical', 'Mid', 'Web development, Python, AWS'
            ).split('\n')[0].replace('Generate a single, concise interview question for a candidate applying for the role of "', '').split('".')[0] + '...';
            D.promptSummary.value = localStorage.getItem('prompt_summary') || PROMPTS.ANSWER_SUMMARY_SCORING('', '').split('\n')[0] + '...';
            D.promptFollowup.value = localStorage.getItem('prompt_followup') || PROMPTS.FOLLOW_UP_SUGGESTION('', '').split('\n')[0] + '...';

        };

        const updateSettingsUI = () => {
             const isDirect = D.apiMode.value === 'direct';
             D.apiKeyGroup.style.display = isDirect ? 'block' : 'none';
             D.showSettingsBtn.setAttribute('aria-expanded', D.settingsPanel.classList.contains('active'));
        };

        const saveSettings = () => {
            STATE.apiMode = D.apiMode.value;
            STATE.apiKey = D.apiKeyInput.value.trim();
            STATE.proxyEnabled = STATE.apiMode === 'proxy';

            localStorage.setItem('interna_settings', JSON.stringify({
                apiMode: STATE.apiMode,
                apiKey: STATE.apiKey
            }));
            
            showAlert('Settings saved!', 'success', 3000);
            D.settingsPanel.classList.add('hidden');
        };

        const savePrompts = () => {
            // Note: In a real application, we'd use these textareas to dynamically update the PROMPTS object
            // For this demo, we save the text as a placeholder/power-user feature.
            localStorage.setItem('prompt_question', D.promptQuestion.value);
            localStorage.setItem('prompt_summary', D.promptSummary.value);
            localStorage.setItem('prompt_followup', D.promptFollowup.value);
            showAlert('Prompt templates saved!', 'success', 3000);
        };
        
        /**
         * Self-test function to verify client-side and API connectivity.
         */
        const runSelfTest = async () => {
            D.selfTestResults.innerHTML = "Running tests... <span class='loading-spinner'></span>";
            
            const results = [];
            const role = D.roleApplied.value || 'Developer';

            results.push(`‚úÖ Client-side UI initialized.`);
            results.push(`‚úÖ API Mode: <strong>${STATE.apiMode}</strong> (${STATE.proxyEnabled ? 'Proxy Enabled' : 'Direct Enabled'})`);
            if (STATE.apiMode === 'direct' && !STATE.apiKey) {
                 results.push(`‚ö†Ô∏è Direct Mode: API Key is empty. Live API test will fail.`);
            }

            const testPrompt = PROMPTS.QUESTION_GENERATION(role, 3, 'Technical', 'Mid', 'Testing context').substring(0, 500);
            
            try {
                const testResult = await callGeminiAPI(testPrompt, false);
                results.push(`‚úÖ API Call successful! Response length: ${testResult.length} chars.`);
            } catch (error) {
                results.push(`‚ùå API Call Failed. Check Console. Error: ${error.message}`);
                showAlert('Self-Test failed one or more API checks.', 'danger', 10000);
            }

            D.selfTestResults.innerHTML = results.map(r => `<p style="margin-top: 4px;">${r}</p>`).join('');
            showAlert('Self-Test complete. See results below.', 'success', 5000);
        };


        // --- Event Listeners ---
        const setupListeners = () => {
            D.intakeForm.addEventListener('submit', startInterview);
            D.resumeUpload.addEventListener('change', handleResumeUpload);
            D.candidateAnswer.addEventListener('input', (event) => {
                const len = event.target.value.length;
                D.charCount.textContent = len;
            });

            D.answerQuality.addEventListener('input', (event) => {
                D.qualityDisplay.textContent = `${event.target.value}/5`;
            });

            D.submitAnswerBtn.addEventListener('click', submitAnswer);
            D.suggestFollowupBtn.addEventListener('click', suggestFollowUp);
            D.endInterviewBtn.addEventListener('click', endInterview);
            D.runSelfTestBtn.addEventListener('click', runSelfTest);

            // Settings listeners
            D.showSettingsBtn.addEventListener('click', () => {
                D.settingsPanel.classList.toggle('hidden');
                D.showSettingsBtn.setAttribute('aria-expanded', !D.settingsPanel.classList.contains('hidden'));
                updateSettingsUI();
            });
            D.saveSettingsBtn.addEventListener('click', saveSettings);
            D.apiMode.addEventListener('change', updateSettingsUI);
            D.savePromptsBtn.addEventListener('click', savePrompts);
            D.resetAppBtn.addEventListener('click', () => {
                localStorage.removeItem('interna_settings');
                localStorage.removeItem('prompt_question');
                localStorage.removeItem('prompt_summary');
                localStorage.removeItem('prompt_followup');
                window.location.reload();
            });
        };
        
        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings();
            setupListeners();
            // Initial check for API key in direct mode
            if (STATE.apiMode === 'direct' && !STATE.apiKey) {
                 showAlert('API Key is missing in Direct Mode. Open Settings to set it.', 'danger', 15000);
            }
        });
        
    </script>
</body>
</html>
